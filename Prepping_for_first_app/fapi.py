#
#  This is fapi - the fake api which is an attempt to isolate the layer of calls that 
#  are anticipated to handled by the graphDB.   If this works, it should be possible to 
#  rewrite these functions/procedures to use Arango and run the main app basis program
#  without alteration
#

def get_similar_reactions( reaction_id, other_params ):
   
    print( "Oh HAI this is fapi: {0}".format( reaction_id ) )
 
    # this scans the entire p6_pairs.all file for records which contain
    # target reaction and have both similarities == 1.0    
    # in principle, the similarity threshold cuts would be in the other_params
    # dict, along with any other filtering info

    similarity_file = "/newmount/mccorkle/p6_pairs.all"
    similar_reactions = [ reaction_id ]

    with open( similarity_file ) as sim:
        for line in sim:
            if line[0] != "#":    # skip comments
                rxn_a, rxn_b, struct_sim, diff_sim = line.strip().split()
                if ( rxn_a == reaction_id or rxn_b == reaction_id ) and ( struct_sim == 1 or diff_sim == 1 ):
                    print( "{0}, {1}, {2}, {3}".format( rxn_a, rxn_b, struct_sim, diff_sim ) )
                    if  rxn_a == reaction_id:
                        sim_rxn = rxn_b
                    else:
                        sim_rxn = rxn_a
                    similar_reactions.append( sim_rxn )

    print( "Bye from fapi" )
    return( similar_reactions )


# this simulates a graphDB call by reading the normal table file
# modelseed_rxn_genome_gene.tab, generated by make_normal_modelseed_table.py
# from the ModelSEED model tsv files.
#
# currently this works only for one reaction.   Maybe it should be
# modified to work on a list instead
#
def get_modelseed_genomes_genes( target_rxn ):

    rgg_table = "SupportScripts/modelseed_rxn_genome_gene.tab"
    genes = []

    with open( rgg_table ) as rgg:
        for line in rgg:
            rxn, genome, gene = line.strip().split()
            if rxn == target_rxn:
                genes.append( genome + ':' + gene )

    return( genes )


# this returns a big fasta-format as a string, suitable for printing
#  If genes (list of gene ids) is given, only those genes are returned.
# If not given, all are returned

def get_protein_sequences( genome, genes=None ):
    seqroot = "/newmount/mccorkle/Genomes/ProteinSequences/"

    # make a dict of genome:gene for faster filtering of sequences
    # (thats how these sequences are labeled)

    #print( "get protein sequences {0} {1}".format( genome, genes ) )

    is_target = {}
    if genes:
        for g in genes:
            is_target[ genome + ':' + g ] = True

    keep = False  # filter flag
    ret = ""      # return string, fasta format protein sequences
    #print( "opening file {0}".format( seqroot + genome + ".faa" ) )
    with open( seqroot + genome + ".faa" ) as pf:
        for line in pf:
            if genes:
                if line[0] == '>':
                    if is_target.get( line[1:].strip() ):
                        keep = True
                    else:
                        keep = False
                    #print( "checking {0} {1}".format( line[1:].strip(), keep ) )
            else:
                keep = True

            if keep:
                ret = ret + line

    return( ret )


